name: CD - Staging (Backend)

on:
  push:
    branches: [ dev ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check secrets presence
        run: |
          echo "HAS_HOST=$HAS_HOST"
          echo "HAS_USER=$HAS_USER"
          echo "HAS_PORT=$HAS_PORT"
          echo "HAS_KEY=$HAS_KEY"
        env:
          HAS_HOST: ${{ secrets.STG_SSH_HOST != '' }}
          HAS_USER: ${{ secrets.STG_SSH_USER != '' }}
          HAS_PORT: ${{ secrets.STG_SSH_PORT != '' }}
          HAS_KEY: ${{ secrets.STG_SSH_KEY != '' }}

      - name: Validate SSH inputs
        shell: bash
        run: |
          [ "${{ secrets.STG_SSH_HOST }}" != "" ] || { echo "STG_SSH_HOST missing"; exit 1; }
          [ "${{ secrets.STG_SSH_USER }}" != "" ] || { echo "STG_SSH_USER missing"; exit 1; }
          [ "${{ secrets.STG_SSH_PORT }}" != "" ] || { echo "STG_SSH_PORT missing"; exit 1; }
          [ "${{ secrets.STG_SSH_KEY }}" != "" ] || { echo "STG_SSH_KEY missing"; exit 1; }
          echo "All required SSH secrets are present."

      - name: Test SSH connection
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.STG_SSH_HOST }}
          username: ${{ secrets.STG_SSH_USER }}
          key: ${{ secrets.STG_SSH_KEY }}
          passphrase: ${{ secrets.STG_SSH_PASSPHRASE }}
          port: ${{ secrets.STG_SSH_PORT }}
          script: |
            whoami
            pwd
            echo "SSH OK"

      - name: Build image
        run: docker build --tag backend:${{ github.sha }} .

      - name: Save image to tar
        run: docker save backend:${{ github.sha }} -o app-image.tar

      - name: Adjust permissions for app-image.tar
        run: chmod 644 app-image.tar

      - name: Copy image to staging droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STG_SSH_HOST }}
          username: ${{ secrets.STG_SSH_USER }}
          key: ${{ secrets.STG_SSH_KEY }}
          passphrase: ${{ secrets.STG_SSH_PASSPHRASE }}
          port: ${{ secrets.STG_SSH_PORT }}
          source: "app-image.tar"
          target: "~/"

      - name: Ensure staging .env file exists
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.STG_SSH_HOST }}
          username: ${{ secrets.STG_SSH_USER }}
          key: ${{ secrets.STG_SSH_KEY }}
          passphrase: ${{ secrets.STG_SSH_PASSPHRASE }}
          port: ${{ secrets.STG_SSH_PORT }}
          script: |
            set -e
            ENV_PATH="$HOME/.env.backend.staging"
            cat > "$ENV_PATH" << 'EOF'
            NODE_ENV=staging
            PORT=${{ secrets.STG_APP_PORT }}
            DB_HOST=${{ secrets.STG_DB_HOST }}
            DB_PORT=${{ secrets.STG_DB_PORT }}
            DB_USER=${{ secrets.STG_DB_USER }}
            DB_PASS=${{ secrets.STG_DB_PASS }}
            DB_NAME=${{ secrets.STG_DB_NAME }}
            DB_SSL=${{ secrets.STG_DB_SSL }}
            DB_SSL_REJECT_UNAUTHORIZED=${{ secrets.STG_DB_SSL_REJECT_UNAUTHORIZED }}
            JWT_SECRET=${{ secrets.STG_JWT_SECRET }}
            KICK_CLIENT_ID=${{ secrets.STG_KICK_CLIENT_ID }}
            KICK_CLIENT_SECRET=${{ secrets.STG_KICK_CLIENT_SECRET }}
            KICK_REDIRECT_URI=${{ secrets.STG_KICK_REDIRECT_URI }}
            EOF
            chmod 600 "$ENV_PATH"
            echo "Wrote $ENV_PATH"
            ls -l "$ENV_PATH"

      - name: Deploy on staging via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.STG_SSH_HOST }}
          username: ${{ secrets.STG_SSH_USER }}
          key: ${{ secrets.STG_SSH_KEY }}
          passphrase: ${{ secrets.STG_SSH_PASSPHRASE }}
          port: ${{ secrets.STG_SSH_PORT }}
          script: |
            set -e
            CONTAINER_NAME=backend-stg
            IMAGE_TAG=backend:${{ github.sha }}
            ENV_FILE="$HOME/.env.backend.staging"

            docker load -i ~/app-image.tar
            rm -f ~/app-image.tar

            # Stop and remove previous container if it exists to free the port
            if docker ps -a --format '{{.Names}}' | grep -Eq "^${CONTAINER_NAME}$"; then
              docker rm -f "${CONTAINER_NAME}"
            fi

            # Run migrations in a one-off container (env from file on droplet)
            docker run --rm --env-file "${ENV_FILE}" ${IMAGE_TAG} sh -lc 'echo "→ DB_HOST=$DB_HOST"; echo "→ DB_PORT=$DB_PORT"; echo "→ DB_USER=$DB_USER"; echo "→ DB_NAME=$DB_NAME"; echo "→ NODE_ENV=$NODE_ENV"; npx sequelize db:migrate --debug'

            # Start new container
            docker run -d --name "${CONTAINER_NAME}" --restart unless-stopped \
              --env-file "${ENV_FILE}" -p 3000:3000 ${IMAGE_TAG}
